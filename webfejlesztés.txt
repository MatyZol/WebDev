ne legyen a dependnyk be verziószám ha nem muszáj
annotációval lehet mindennt vezérleni
SpringBootApplication mindnent konfigurál
kell egy kiterjesztés (extends SpringBootServletInitializer) mert weben vagyunk
Ha foglalt a 8080 port akkor a resourcesba kell egy új file application.properties, ahhoz konfigolunk
Ha szerver port tulajdonság változik akkor server.port=8081
sprint profilokkal tutudnk különböző konfigokat csinálni és ki tudjuk választani hpgy melyi legyen aktív és így tudunk különböző adatb. szerverekhez kapcsolódnbi
OffsetDateTime: időzóna,dátum,idő
csak addig van default konstruktor amíg nincs másik ->> ezért kel mind a kettő ha szeretnénk
@EqualsAndHashCode(onlyExplicitlyIncluded = true): csak az fog bekerülni az hashcode ba amit mi szerenénk
|
-->@EqualsAndHashCode.Include megy az adott mező felé

@GetMapping("/api/student") et két metódushoz nem lehet hozzákötni!!!
|
v
@GetMapping("/api/student/{neptun}")
    Student getOne(@PathVariable String neptun); ugyan annak kell lennie a változónak (itt neptun)

lehet neki paraméterezést beállítani @PathVariable("azonosítóval")

/////////////
Component = komponens ->> példányosítania kell a trendszernek
beadandóhoz adat -> JavaFaker
@Repository/@Component osztályt fogja implementálni perzisztenciának
Ha többre teszük rá akkor összeakad a spring -> @Primary val lehet megoldani


RequestBody: PoST  és PUT kérésnél használjuk
a http patheknél a sorrend számít
consume : mit fogad
produces: mit tudunk előállítani
content disposition: milyen néven töltsük le a fájlt
@GetMapping("/api/student/download-v2")
    ResponseEntity<Student> download2();
ezzel tudunk manimulálni a dolgokat

függőség kell az adatbéhjez -> h2 -> memóriában van minden adat
kell még egy starter jpa

.yml kiterjesztésben nem = hanem : kell
|-> fa struktúrát lehet vele csinálni
|-> listákat is lehet csinálni
|-> jobb mint a properties

ha mem-et írunkakkokr mem memóriabeli ha tárhelyre akkor egy eléri út kell

adatb szerver konifig:

server.port: 8081
spring:
  jackson.serialization.indent-output: true
  datasource:
    url: jdbc:h2:mem:testdb
    driver-class-name: org.h2.Driver
    username: sa
    password: pw
-------------------------------------
jpa konfig: lelke a adatbkezelésének

  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    show-sql: true
    generate-ddl: true


generate-ddl: csináljon ddl utsaításokat    

adatb. konfig:

  h2.console:
    enabled: true
    path: /db

-----
CrudRepository<Mi a perzisztencia típusa, mi a kulcs típusa>


@ManyToOne mindig az adott táblából van értelmezve ( az összesnél)



minél kevesebb repo legyen 1 osztályban






